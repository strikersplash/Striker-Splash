import { Request, Response } from "express";
import { pool } from "../../config/db";

interface CompetitionData {
  type: string;
  name: string;
  format?: string;
  team_size?: number;
  cost: number;
  kicks_per_player: number;
  max_participants?: number;
  max_teams?: number;
  description?: string;
  participants?: number[];
  teams?: number[];
}

interface Competition {
  id: number;
  type: string;
  name: string;
  format?: string;
  team_size?: number;
  cost: number;
  kicks_per_player: number;
  max_participants?: number;
  max_teams?: number;
  description?: string;
  status: string;
  created_at: Date;
}

// Display competition setup page
export const getCompetitionSetup = async (
  req: Request,
  res: Response
): Promise<void> => {
  try {
    // Only allow staff to access this page
    if (
      !(req.session as any).user ||
      ((req.session as any).user.role !== "admin" &&
        (req.session as any).user.role !== "staff")
    ) {
      req.flash("error_msg", "Unauthorized access");
      return res.redirect("/auth/login");
    }

    res.render("staff/competition-setup", {
      title: "Competition Setup",
      user: (req.session as any).user,
    });
  } catch (error) {
    console.error("Competition setup error:", error);
    req.flash("error_msg", "An error occurred while loading competition setup");
    res.redirect("/staff/interface");
  }
};

// Create a new competition
export const createCompetition = async (
  req: Request,
  res: Response
): Promise<void> => {
  try {
    // Only allow staff to create competitions
    if (
      !(req.session as any).user ||
      ((req.session as any).user.role !== "admin" &&
        (req.session as any).user.role !== "staff")
    ) {
      res.status(401).json({ success: false, message: "Unauthorized access" });
      return;
    }

    const competitionData: CompetitionData = req.body;

    // Validate required fields
    if (
      !competitionData.name ||
      !competitionData.type ||
      competitionData.cost < 0
    ) {
      res.status(400).json({
        success: false,
        message: "Name, type, and valid cost are required",
      });
      return;
    }

    const client = await pool.connect();

    try {
      await client.query("BEGIN");

      // Create competition record
      const competitionQuery = `
        INSERT INTO custom_competitions (
          name, type, format, team_size, cost, kicks_per_player, 
          max_participants, max_teams, description, status, created_by, created_at
        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, 'waiting', $10, NOW())
        RETURNING *
      `;

      const competitionValues = [
        competitionData.name,
        competitionData.type,
        competitionData.format || null,
        competitionData.team_size || null,
        competitionData.cost,
        competitionData.kicks_per_player,
        competitionData.max_participants || null,
        competitionData.max_teams || null,
        competitionData.description || null,
        (req.session as any).user.id,
      ];

      const competitionResult = await client.query(
        competitionQuery,
        competitionValues
      );
      const competition = competitionResult.rows[0];

      // Add participants/teams
      if (
        competitionData.type === "individual" &&
        competitionData.participants
      ) {
        for (const participantId of competitionData.participants) {
          await client.query(
            `INSERT INTO custom_competition_participants (competition_id, player_id, goals, kicks_taken, status)
             VALUES ($1, $2, 0, 0, 'registered')`,
            [competition.id, participantId]
          );
        }
      } else if (competitionData.type === "team" && competitionData.teams) {
        for (const teamId of competitionData.teams) {
          await client.query(
            `INSERT INTO custom_competition_teams (competition_id, team_id, total_goals, total_kicks, status)
             VALUES ($1, $2, 0, 0, 'registered')`,
            [competition.id, teamId]
          );
        }
      }

      await client.query("COMMIT");

      res.json({
        success: true,
        message: "Competition created successfully",
        competition: competition,
      });
    } catch (error) {
      await client.query("ROLLBACK");
      throw error;
    } finally {
      client.release();
    }
  } catch (error) {
    console.error("Error creating competition:", error);
    res.status(500).json({
      success: false,
      message: "An error occurred while creating the competition",
    });
  }
};

// Get competition queue
export const getCompetitionQueue = async (
  req: Request,
  res: Response
): Promise<void> => {
  try {
    const query = `
      SELECT 
        cc.*,
        COUNT(DISTINCT ccp.player_id) as participant_count,
        COUNT(DISTINCT cct.team_id) as team_count
      FROM custom_competitions cc
      LEFT JOIN custom_competition_participants ccp ON cc.id = ccp.competition_id
      LEFT JOIN custom_competition_teams cct ON cc.id = cct.competition_id
      WHERE cc.status IN ('waiting', 'active')
      GROUP BY cc.id
      ORDER BY cc.created_at ASC
    `;

    const result = await pool.query(query);
    const competitions = result.rows.map((comp) => ({
      ...comp,
      participant_count:
        comp.type === "individual" ? comp.participant_count : comp.team_count,
    }));

    res.json({
      success: true,
      competitions: competitions,
    });
  } catch (error) {
    console.error("Error getting competition queue:", error);
    res.status(500).json({
      success: false,
      message: "An error occurred while getting the competition queue",
    });
  }
};

// Start a competition
export const startCompetition = async (
  req: Request,
  res: Response
): Promise<void> => {
  try {
    const { id } = req.params;

    // Update competition status to active
    const updateQuery = `
      UPDATE custom_competitions 
      SET status = 'active', started_at = NOW()
      WHERE id = $1 AND status = 'waiting'
      RETURNING *
    `;

    const result = await pool.query(updateQuery, [id]);

    if (result.rows.length === 0) {
      res.status(404).json({
        success: false,
        message: "Competition not found or already started",
      });
      return;
    }

    res.json({
      success: true,
      message: "Competition started successfully",
      competition: result.rows[0],
    });
  } catch (error) {
    console.error("Error starting competition:", error);
    res.status(500).json({
      success: false,
      message: "An error occurred while starting the competition",
    });
  }
};

// End a competition
export const endCompetition = async (
  req: Request,
  res: Response
): Promise<void> => {
  try {
    const { id } = req.params;

    const client = await pool.connect();

    try {
      await client.query("BEGIN");

      // Update competition status to completed
      const updateQuery = `
        UPDATE custom_competitions 
        SET status = 'completed', ended_at = NOW()
        WHERE id = $1 AND status = 'active'
        RETURNING *
      `;

      const result = await client.query(updateQuery, [id]);

      if (result.rows.length === 0) {
        await client.query("ROLLBACK");
        res.status(404).json({
          success: false,
          message: "Competition not found or not active",
        });
        return;
      }

      const competition = result.rows[0];

      // Update participant/team statuses
      if (competition.type === "individual") {
        await client.query(
          `UPDATE custom_competition_participants SET status = 'completed' WHERE competition_id = $1`,
          [id]
        );
      } else {
        await client.query(
          `UPDATE custom_competition_teams SET status = 'completed' WHERE competition_id = $1`,
          [id]
        );
      }

      await client.query("COMMIT");

      res.json({
        success: true,
        message: "Competition ended successfully",
        competition: competition,
      });
    } catch (error) {
      await client.query("ROLLBACK");
      throw error;
    } finally {
      client.release();
    }
  } catch (error) {
    console.error("Error ending competition:", error);
    res.status(500).json({
      success: false,
      message: "An error occurred while ending the competition",
    });
  }
};

// Cancel a competition
export const cancelCompetition = async (
  req: Request,
  res: Response
): Promise<void> => {
  try {
    const { id } = req.params;

    // Update competition status to cancelled
    const updateQuery = `
      UPDATE custom_competitions 
      SET status = 'cancelled', ended_at = NOW()
      WHERE id = $1 AND status IN ('waiting', 'active')
      RETURNING *
    `;

    const result = await pool.query(updateQuery, [id]);

    if (result.rows.length === 0) {
      res.status(404).json({
        success: false,
        message: "Competition not found or already completed",
      });
      return;
    }

    res.json({
      success: true,
      message: "Competition cancelled successfully",
      competition: result.rows[0],
    });
  } catch (error) {
    console.error("Error cancelling competition:", error);
    res.status(500).json({
      success: false,
      message: "An error occurred while cancelling the competition",
    });
  }
};

// Get competition live view
export const getCompetitionLive = async (
  req: Request,
  res: Response
): Promise<void> => {
  try {
    const { id } = req.params;

    // Get competition details
    const competitionQuery = `
      SELECT * FROM custom_competitions WHERE id = $1
    `;
    const competitionResult = await pool.query(competitionQuery, [id]);

    if (competitionResult.rows.length === 0) {
      res.status(404).render("system/error", {
        title: "Competition Not Found",
        code: 404,
        message: "Competition not found",
      });
      return;
    }

    const competition = competitionResult.rows[0];

    if (competition.type === "individual") {
      // Get participants
      const participantsQuery = `
        SELECT 
          ccp.*,
          p.name,
          p.age_group,
          p.residence
        FROM custom_competition_participants ccp
        JOIN players p ON ccp.player_id = p.id
        WHERE ccp.competition_id = $1
        ORDER BY ccp.goals DESC, ccp.kicks_taken ASC
      `;
      const participantsResult = await pool.query(participantsQuery, [id]);

      // Calculate format based on number of players
      const participantCount = participantsResult.rows.length;
      let format = "Individual";
      if (participantCount === 2) {
        format = "1v1";
      } else if (participantCount === 3) {
        format = "1v1v1";
      } else if (participantCount > 3) {
        format = `${participantCount} Players`;
      }

      res.render("staff/competition-live", {
        title: `Live Competition: ${competition.name}`,
        competition: { ...competition, format },
        participants: participantsResult.rows,
        teams: [],
        user: (req.session as any).user,
      });
    } else {
      // Get teams
      const teamsQuery = `
        SELECT 
          cct.*,
          t.name,
          p.name as captain_name,
          COUNT(tm.player_id) as member_count
        FROM custom_competition_teams cct
        JOIN teams t ON cct.team_id = t.id
        JOIN team_members tm_captain ON t.id = tm_captain.team_id AND tm_captain.is_captain = true
        JOIN players p ON tm_captain.player_id = p.id
        LEFT JOIN team_members tm ON t.id = tm.team_id
        WHERE cct.competition_id = $1
        GROUP BY cct.id, t.id, t.name, p.name
        ORDER BY cct.total_goals DESC, cct.total_kicks ASC
      `;
      const teamsResult = await pool.query(teamsQuery, [id]);

      res.render("staff/competition-live", {
        title: `Live Competition: ${competition.name}`,
        competition: competition,
        participants: [],
        teams: teamsResult.rows,
        user: (req.session as any).user,
      });
    }
  } catch (error) {
    console.error("Error loading competition live view:", error);
    res.status(500).render("system/error", {
      title: "Server Error",
      code: 500,
      message: "Failed to load competition live view",
    });
  }
};

// Get individual competition leaderboard
export const getIndividualLeaderboard = async (
  req: Request,
  res: Response
): Promise<void> => {
  try {
    const { id } = req.params;

    const query = `
      SELECT 
        ccp.*,
        p.name,
        p.age_group,
        p.residence,
        CASE 
          WHEN ccp.kicks_taken > 0 THEN TRUNC((ccp.goals::NUMERIC / ccp.kicks_taken) * 100, 1)
          ELSE 0 
        END as accuracy
      FROM custom_competition_participants ccp
      JOIN players p ON ccp.player_id = p.id
      WHERE ccp.competition_id = $1
      ORDER BY ccp.goals DESC, accuracy DESC, ccp.kicks_taken ASC
    `;

    const result = await pool.query(query, [id]);

    res.json({
      success: true,
      leaderboard: result.rows,
      participants: result.rows,
    });
  } catch (error) {
    console.error("Error getting individual leaderboard:", error);
    res.status(500).json({
      success: false,
      message: "An error occurred while getting the leaderboard",
    });
  }
};

// Get team competition leaderboard
export const getTeamLeaderboard = async (
  req: Request,
  res: Response
): Promise<void> => {
  try {
    const { id } = req.params;

    const query = `
      SELECT 
        cct.*,
        t.name,
        CASE 
          WHEN cct.total_kicks > 0 THEN TRUNC((cct.total_goals::NUMERIC / cct.total_kicks) * 100, 1)
          ELSE 0 
        END as accuracy
      FROM custom_competition_teams cct
      JOIN teams t ON cct.team_id = t.id
      WHERE cct.competition_id = $1
      ORDER BY cct.total_goals DESC, accuracy DESC, cct.total_kicks ASC
    `;

    const result = await pool.query(query, [id]);

    res.json({
      success: true,
      leaderboard: result.rows,
      teams: result.rows,
    });
  } catch (error) {
    console.error("Error getting team leaderboard:", error);
    res.status(500).json({
      success: false,
      message: "An error occurred while getting the team leaderboard",
    });
  }
};

// Log goals in competition
export const logCompetitionGoals = async (
  req: Request,
  res: Response
): Promise<void> => {
  try {
    console.log("Log goals request body:", req.body);

    const {
      competitionId,
      participantId,
      teamId,
      kicksUsed,
      goals,
      consecutiveKicks,
      notes,
    } = req.body;

    console.log("Parsed values:", {
      competitionId,
      participantId,
      teamId,
      kicksUsed,
      goals,
      consecutiveKicks,
      notes,
    });

    // Validate input
    if (!competitionId) {
      console.error("Missing competition ID");
      res.status(400).json({
        success: false,
        message: "Competition ID is required",
      });
      return;
    }

    if (!participantId) {
      console.error("Missing participant ID");
      res.status(400).json({
        success: false,
        message: "Participant ID is required",
      });
      return;
    }

    if (kicksUsed === undefined) {
      console.error("Missing kicks used");
      res.status(400).json({
        success: false,
        message: "Kicks used is required",
      });
      return;
    }

    if (goals === undefined) {
      console.error("Missing goals");
      res.status(400).json({
        success: false,
        message: "Goals is required",
      });
      return;
    }

    const client = await pool.connect();

    try {
      console.log("Starting database transaction");
      await client.query("BEGIN");

      // Check if user session exists and get user ID
      let userId = 1; // Default to ID 1 if session doesn't exist

      try {
        if (
          req.session &&
          (req.session as any).user &&
          (req.session as any).user.id
        ) {
          userId = (req.session as any).user.id;
        } else {
          console.warn("User session not found, using default user ID");
        }
      } catch (error) {
        console.error("Error accessing user session:", error);
      }

      // Get competition details
      const competitionQuery = `SELECT * FROM custom_competitions WHERE id = $1`;
      console.log("Competition query:", competitionQuery, [competitionId]);

      const competitionResult = await client.query(competitionQuery, [
        competitionId,
      ]);

      console.log(
        "Competition query result rows:",
        competitionResult.rows.length
      );

      if (competitionResult.rows.length === 0) {
        console.error("Competition not found with ID:", competitionId);
        await client.query("ROLLBACK");
        res.status(404).json({
          success: false,
          message: "Competition not found",
        });
        return;
      }

      console.log("Found competition:", competitionResult.rows[0]);

      const competition = competitionResult.rows[0];
      let actualPlayerId;

      // Make sure participantId is treated as a number if it's a valid number string
      if (participantId && !isNaN(parseInt(participantId))) {
        actualPlayerId = parseInt(participantId);
        console.log("Converted participantId to number:", actualPlayerId);
      } else {
        console.error("Invalid participantId:", participantId);
        await client.query("ROLLBACK");
        res.status(400).json({
          success: false,
          message: "Invalid participant ID",
        });
        return;
      }

      if (competition.type === "individual") {
        // Update individual participant
        const updateQuery = `
          UPDATE custom_competition_participants 
          SET goals = goals + $1, kicks_taken = kicks_taken + $2
          WHERE id = $3
          RETURNING *
        `;

        console.log("Participant update query:", updateQuery);
        console.log("Participant update parameters:", [
          goals,
          kicksUsed,
          participantId,
        ]);

        const updateResult = await client.query(updateQuery, [
          goals,
          kicksUsed,
          participantId,
        ]);
        console.log("Participant update result:", updateResult.rows);

        if (updateResult.rows.length === 0) {
          console.error("No participant found to update");
          await client.query("ROLLBACK");
          res.status(404).json({
            success: false,
            message: "Participant not found in competition",
          });
          return;
        }

        console.log("Updated participant:", updateResult.rows[0]);

        // Get the player_id from the updated participant record for activity logging
        const updatedParticipant = updateResult.rows[0];
        actualPlayerId = updatedParticipant.player_id;

        // Also insert into game_stats to make it appear in the global leaderboard
        if (goals > 0) {
          const gameStatsQuery = `
            INSERT INTO game_stats (
              player_id, staff_id, goals, location, competition_type, 
              consecutive_kicks, kicks_used, timestamp
            ) VALUES ($1, $2, $3, $4, $5, $6, $7, NOW())
            RETURNING id
          `;

          const gameStatsParams = [
            actualPlayerId,
            userId, // staff_id
            goals,
            "Custom Competition", // location
            "custom_competition", // competition_type
            consecutiveKicks || null,
            kicksUsed,
          ];

          try {
            const gameStatsResult = await client.query(
              gameStatsQuery,
              gameStatsParams
            );
            console.log(
              "Custom competition goals added to global leaderboard with ID:",
              gameStatsResult.rows[0]?.id
            );
          } catch (error) {
            console.error("Error inserting game stats:", error);
            // Don't fail the entire operation if game_stats fails
          }
        }
      } else if (competition.type === "team") {
        // For team competitions, we need to handle two cases:
        // 1. If teamId is provided, use that directly
        // 2. If only participantId is provided, find the team the player belongs to
        
        let teamIdToUpdate = null;
        
        if (teamId && teamId !== "null" && teamId !== "") {
          teamIdToUpdate = parseInt(teamId);
          console.log("Using provided teamId:", teamIdToUpdate);
        } else {
          // Find which team the player belongs to
          const findTeamQuery = `
            SELECT tm.team_id 
            FROM team_members tm
            JOIN teams t ON tm.team_id = t.id
            JOIN custom_competition_teams cct ON cct.team_id = t.id
            WHERE tm.player_id = $1 AND cct.competition_id = $2
          `;
          
          const findTeamResult = await client.query(findTeamQuery, [actualPlayerId, competitionId]);
          
          if (findTeamResult.rows.length > 0) {
            teamIdToUpdate = findTeamResult.rows[0].team_id;
            console.log("Found team for player:", teamIdToUpdate);
          } else {
            console.error("No team found for player:", actualPlayerId);
            await client.query("ROLLBACK");
            res.status(404).json({
              success: false,
              message: "Player is not part of any team in this competition"
            });
            return;
          }
        }
        
        if (teamIdToUpdate) {
          console.log("Updating team stats for team ID:", teamIdToUpdate);
          // Update team stats
          const updateTeamQuery = `
            UPDATE custom_competition_teams 
            SET total_goals = total_goals + $1, total_kicks = total_kicks + $2
            WHERE competition_id = $3 AND team_id = $4
            RETURNING *
          `;
          const teamUpdateResult = await client.query(updateTeamQuery, [
            goals,
            kicksUsed,
            competitionId,
            teamIdToUpdate,
          ]);

          console.log("Team stats updated:", teamUpdateResult.rows[0]);

          // Also update team_stats to reflect in the global team leaderboard
          try {
            const teamStatsQuery = `
              INSERT INTO team_stats (
                team_id, competition_id, goals, kicks, added_at
              ) VALUES ($1, $2, $3, $4, NOW())
              ON CONFLICT (team_id, competition_id) 
              DO UPDATE SET 
                goals = team_stats.goals + EXCLUDED.goals,
                kicks = team_stats.kicks + EXCLUDED.kicks
              RETURNING *
            `;

            const teamStatsResult = await client.query(teamStatsQuery, [
              teamIdToUpdate,
              competitionId,
              goals,
              kicksUsed,
            ]);

            console.log("Team global stats updated:", teamStatsResult.rows[0]);
          } catch (error) {
            console.error("Error updating team global stats:", error);
            // Continue with the transaction - don't fail the operation if team_stats update fails
          }
        }
      } else {
        console.error("Unknown competition type:", competition.type);
        await client.query("ROLLBACK");
        res.status(400).json({
          success: false,
          message: "Unknown competition type"
        });
        return;
      }
        console.log("Updating team stats for team ID:", teamId);
        // Update team stats
        const updateTeamQuery = `
          UPDATE custom_competition_teams 
          SET total_goals = total_goals + $1, total_kicks = total_kicks + $2
          WHERE competition_id = $3 AND team_id = $4
          RETURNING *
        `;
        const teamUpdateResult = await client.query(updateTeamQuery, [
          goals,
          kicksUsed,
          competitionId,
          teamId,
        ]);

        console.log("Team stats updated:", teamUpdateResult.rows[0]);

        // Also update team_stats to reflect in the global team leaderboard
        try {
          const teamStatsQuery = `
            INSERT INTO team_stats (
              team_id, competition_id, goals, kicks, added_at
            ) VALUES ($1, $2, $3, $4, NOW())
            ON CONFLICT (team_id, competition_id) 
            DO UPDATE SET 
              goals = team_stats.goals + EXCLUDED.goals,
              kicks = team_stats.kicks + EXCLUDED.kicks
            RETURNING *
          `;

          const teamStatsResult = await client.query(teamStatsQuery, [
            teamId,
            competitionId,
            goals,
            kicksUsed,
          ]);

          console.log("Team global stats updated:", teamStatsResult.rows[0]);
        } catch (error) {
          console.error("Error updating team global stats:", error);
          // Continue with the transaction - don't fail the operation if team_stats update fails
        }
      }

      // Log the activity
      const activityQuery = `
        INSERT INTO custom_competition_activity (
          competition_id, player_id, team_id, goals, kicks_used, 
          consecutive_kicks, notes, logged_by, logged_at
        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, NOW())
        RETURNING id
      `;

      // Log user ID from session (safely)
      try {
        console.log("Session exists:", !!req.session);
        console.log(
          "User in session:",
          !!(req.session && (req.session as any).user)
        );
        console.log(
          "User ID from session:",
          req.session && (req.session as any).user
            ? (req.session as any).user.id
            : "Not available"
        );
      } catch (error) {
        console.error("Error logging session info:", error);
      }

      // Log activity parameters
      // userId was already declared and set above

      // Handle team ID - make sure it's a number if provided
      let processedTeamId = null;
      if (
        teamId &&
        teamId !== "null" &&
        teamId !== "" &&
        !isNaN(parseInt(teamId))
      ) {
        processedTeamId = parseInt(teamId);
        console.log("Converted teamId to number:", processedTeamId);
      }

      const activityParams = [
        parseInt(competitionId),
        actualPlayerId, // Already validated and converted to number above
        processedTeamId,
        parseInt(goals),
        parseInt(kicksUsed),
        consecutiveKicks ? parseInt(consecutiveKicks) : null,
        notes || null,
        userId,
      ];

      console.log("Activity insertion parameters:", activityParams);

      try {
        const activityResult = await client.query(
          activityQuery,
          activityParams
        );
        console.log("Activity inserted with ID:", activityResult.rows[0]?.id);
      } catch (error) {
        console.error("Error inserting activity:", error);
        throw new Error(
          `Failed to insert activity: ${
            error instanceof Error ? error.message : "Unknown error"
          }`
        );
      }

      await client.query("COMMIT");

      res.json({
        success: true,
        message: "Goals logged successfully",
      });
    } catch (error) {
      await client.query("ROLLBACK");
      throw error;
    } finally {
      client.release();
    }
  } catch (error) {
    console.error("Error logging competition goals:", error);
    // Log more detailed error information
    if (error instanceof Error) {
      console.error("Error message:", error.message);
      console.error("Error stack:", error.stack);
    }

    res.status(500).json({
      success: false,
      message:
        error instanceof Error
          ? error.message
          : "An error occurred while logging goals",
    });
  }
};

// Get competition activity
export const getCompetitionActivity = async (
  req: Request,
  res: Response
): Promise<void> => {
  try {
    const { id } = req.params;

    const query = `
      SELECT 
        cca.*,
        p.name as player_name,
        t.name as team_name
      FROM custom_competition_activity cca
      JOIN players p ON cca.player_id = p.id
      LEFT JOIN teams t ON cca.team_id = t.id
      WHERE cca.competition_id = $1
      ORDER BY cca.logged_at DESC
    `;

    const result = await pool.query(query, [id]);

    res.json({
      success: true,
      activity: result.rows,
    });
  } catch (error) {
    console.error("Error getting competition activity:", error);
    res.status(500).json({
      success: false,
      message: "An error occurred while getting competition activity",
    });
  }
};
